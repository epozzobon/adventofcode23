package main

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
)

type module struct {
	typ    string
	name   string
	dst    []string
	memory map[string]int
	state  int
}

type pulse struct {
	src   string
	dst   string
	level int
}

var modules = make(map[string]*module)

func main() {
	file, err := os.Open("input.txt")
	if err != nil {
		panic(err)
	}
	defer file.Close()

	re1 := regexp.MustCompile(`^([%&]?)([a-z]+) -> ([a-z, ]+)$`)
	re2 := regexp.MustCompile(`([a-z])+`)
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		txt := scanner.Text()
		if txt == "" {
			break
		}
		pieces := re1.FindSubmatch([]byte(txt))
		moduleType := string(pieces[1])
		moduleName := string(pieces[2])
		spieces := re2.FindAll(pieces[3], -1)

		moduleDestinations := make([]string, len(spieces))
		for i, spiece := range spieces {
			moduleDestinations[i] = string(spiece)
		}
		fmt.Println(spieces)

		modules[moduleName] = &module{moduleType, moduleName, moduleDestinations, make(map[string]int), -1}
	}

	err = scanner.Err()
	if err != nil {
		panic("input read error")
	}

	for _, m := range modules {
		for _, s := range m.dst {
			if modules[s] == nil {
				modules[s] = &module{"", s, []string{}, make(map[string]int), -1}
			}
			modules[s].memory[m.name] = -1
		}
	}

	highPulses := 0
	lowPulses := 0
	rxPulses := 0
	doButton := func() {
		//fmt.Println("button -low-> broadcaster")
		lowPulses++
		pulseBackLog := []pulse{{"-1", "broadcaster", -1}}
		doPulse := func(m module) {
			//var stateStr string
			if m.state == 1 {
				//stateStr = "high"
				highPulses += len(m.dst)
			} else if m.state == -1 {
				//stateStr = "low"
				lowPulses += len(m.dst)
			}
			for _, d := range m.dst {
				//fmt.Printf("%s -%s-> %s\n", m.name, stateStr, d)
				pulseBackLog = append(pulseBackLog, pulse{m.name, d, m.state})
				modules[d].memory[m.name] = m.state
				if d == "rx" && m.state == -1 {
					rxPulses++
					fmt.Printf("rx pulsed")
				}
			}
		}
		for len(pulseBackLog) > 0 {
			p := pulseBackLog[0]
			pulseBackLog = pulseBackLog[1:]
			m := modules[p.dst]
			if m.name == "" {
				panic("Module not found")
			}
			if m.typ == "" {
				m.state = p.level
				doPulse(*m)
			} else if m.typ == "&" {
				m.state = -1
				for _, s := range m.memory {
					if s == -1 {
						m.state = 1
					}
				}
				doPulse(*m)
			} else if m.typ == "%" {
				if p.level == -1 {
					m.state = -m.state
					doPulse(*m)
				}
			} else {
				fmt.Println(m)
				panic("unknown module")
			}
		}
	}
	for i := 0; i < 1000; i++ {
		doButton()
	}
	fmt.Println(lowPulses, highPulses, highPulses*lowPulses, rxPulses)

}
