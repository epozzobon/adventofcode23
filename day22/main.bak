package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
	"strconv"
	"strings"
)

type v3 struct {
	x int
	y int
	z int
}

type brick struct {
	p0        v3
	p1        v3
	id        int
	supports  map[int]*brick
	supported map[int]*brick
}

func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func (self brick) size() v3 {
	return v3{(self.p0.x - self.p1.x), (self.p0.y - self.p1.y), (self.p0.z - self.p1.z)}
}

func makeStrId(i int) string {
	return string([]rune{rune('A' + i%26), rune('A' + (i/26)%26), rune('A' + (i/26/26)%26)})
}

func main() {

	file, err := os.Open("input.txt")
	if err != nil {
		panic(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)

	bricks := []*brick{}
	i := 0
	for scanner.Scan() {
		txt := scanner.Text()
		ps := strings.Split(txt, "~")
		ps = append(strings.Split(ps[0], ","), strings.Split(ps[1], ",")...)
		p := make([]int, len(ps))
		for i, s := range ps {
			p[i], err = strconv.Atoi(s)
			if err != nil {
				panic("Not a number")
			}
		}
		b := brick{v3{p[0], p[1], p[2]}, v3{p[3], p[4], p[5]}, i, make(map[int]*brick), make(map[int]*brick)}
		i++
		if b.p0.z > b.p1.z || b.p0.y > b.p1.y || b.p0.x > b.p1.x {
			panic("Inversed coordinates")
		}
		bricks = append(bricks, &b)
	}

	fmt.Println(len(bricks))

	minZ, maxZ := bricks[0].p0.z, bricks[0].p1.z
	minX, maxX := bricks[0].p0.x, bricks[0].p1.x
	minY, maxY := bricks[0].p0.y, bricks[0].p1.y
	for i := 0; i < len(bricks); i++ {
		minX = min(bricks[i].p0.x, minX)
		minY = min(bricks[i].p0.y, minY)
		minZ = min(bricks[i].p0.z, minZ)
		maxX = max(bricks[i].p1.x, maxX)
		maxY = max(bricks[i].p1.y, maxY)
		maxZ = max(bricks[i].p1.z, maxZ)
	}
	for i := 0; i < len(bricks); i++ {
		bricks[i].p0.x -= minX
		bricks[i].p1.x -= minX
		bricks[i].p0.y -= minY
		bricks[i].p1.y -= minY
		bricks[i].p0.z -= minZ
		bricks[i].p1.z -= minZ
	}
	maxX -= minX
	maxY -= minY
	maxZ -= minZ

	zplane := make([][]*brick, maxX+1)
	for x := 0; x <= maxX; x++ {
		zplane[x] = make([]*brick, maxY+1)
	}

	sort.SliceStable(bricks, func(i, j int) bool {
		return bricks[i].p0.z < bricks[j].p0.z
	})

	fmt.Println(bricks)

	for i := 0; i < len(bricks); i++ {
		b := bricks[i]
		maxZ := -1
		for x := b.p0.x; x <= b.p1.x; x++ {
			for y := b.p0.y; y <= b.p1.y; y++ {
				if zplane[x][y] != nil {
					if maxZ == zplane[x][y].p1.z {
						b.supports[zplane[x][y].id] = zplane[x][y]
					} else if maxZ < zplane[x][y].p1.z {
						maxZ = zplane[x][y].p1.z
						b.supports = map[int]*brick{zplane[x][y].id: zplane[x][y]}
					}
				}
				zplane[x][y] = b
			}
		}
		for x := 0; x < len(zplane); x++ {
			for y := 0; y < len(zplane[x]); y++ {
				bid := "   "
				if zplane[x][y] != nil {
					bid = makeStrId(zplane[x][y].id)
				}
				fmt.Printf("%s,", bid)
			}
			fmt.Printf("\n")
		}
		fmt.Printf("\n")
		offZ := b.p0.z - maxZ - 1
		b.p0.z -= offZ
		b.p1.z -= offZ
	}

	for _, b := range bricks {
		fmt.Printf("%s supported by ", makeStrId(b.id))
		for _, s := range b.supports {
			fmt.Printf("%s, ", makeStrId(s.id))
			s.supported[b.id] = b
		}
		fmt.Printf("\n")
	}

	for _, b := range bricks {
		fmt.Printf("%s supports ", makeStrId(b.id))
		for _, s := range b.supported {
			fmt.Printf("%s, ", makeStrId(s.id))
		}
		fmt.Printf("\n")
	}

	sum := 0
	for _, b := range bricks {
		soleSupport := false
		for _, s := range b.supported {
			if len(s.supports) == 1 {
				soleSupport = true
			}
		}
		if !soleSupport {
			sum++
			fmt.Printf("%s can be disintegrated\n", makeStrId(b.id))
		}
	}
	fmt.Println(sum)
}
